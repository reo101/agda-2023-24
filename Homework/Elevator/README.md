## Моделиране на прост асансьор

Ще моделираме много прост асансьор и ще докажем няколко свойства за него.

Никъде няма да моделираме етажи с цел да не усложняваме задачата допълнително.

Задачите имат скелет с нужните import-и за решаването им в същата папка в която се намират тези условия.

### `State`
```agda
data State : Set where
```
Дефинирайте нов тип данни който изразява състоянието на асансьор. Нека го наречем `State`.
Нашият асансьор ще поддържа:
  1. незаетост - асансьор си седи на едно място и няма задача която изпълнява
  2. затваряне на врати - асансьорът се приготвя да започне пътуване към даден етаж, което може да бъде прекъснато
  3. предвижване към - асансьорът е зает и финализирал че ще пътува към етаж

#### `eqState : State -> State -> Two`
Ще ни се наложи по-късно да различаваме дали две състояния са равни.

Имплементирайте функция, по два `State`-а, връща дали са равни под формата на булева стойност `Two`.


### `Action`
```agda
data Action : State -> Set where
```

Дефинирайте нов тип данни, който изразява възможните събития, които асансьорът ни ще обработва. Нека го наречем `Action`.
  1. "повикване на" - някой е повикал асансьора на етаж, който е различен от сегашния етаж на асансьора
  2. "закарване на" - някой е натиснал бутон от вътре в асансьора с цел да отида на пожелания етаж
  3. "отваряне на врати" - някой е помолил вратите да се отворят, докато са били в процес на затваряне, прекъсвайки сегашната му команда
  4. "вратите са се затворили" - докато асансьорът е в състояние в което затваря вратите си, те успешно са се затворили
  5. "пристигнал на" - асансьорът успешно е пристингал на даден етаж, докато е пътувал към него

Ще направим `Action` да е тип индексиран по `State`, за да можем да се възползваме да гарантираме няколко свойства:
  1. Асансьорът може да бъде "повикван на" и "закарван на" само докато не е зает.
  2. Позволяваме "отваряне на врати" само докато асансьорът е в процес на затваряне на врати
  3. Позволяваме да получим събитие че вратите са затворени само докато те са в процес на затваряне
  4. Позволяваме да получим събитие че сме стигнали на етаж, само когато асансьорът пътува.

### `transition`
```agda
transition : (s : State) -> Action s -> State
```

Имплементирайте функция, която по дадено състояние и действие позволено от това състояние, връща следващото състояние в което би попаднал асансьорът.

Ще искаме `transition` да изпълнява няколко свойства, които вие ще имате за задача да формулирате и докажете.
За да изразите тези свойства, можете да използвате `eqState`, както и `Is` конструкцията.

#### Не можем да прекъсваме предвижването на асансьора
Докато асансьорът е в състояние на "предвидване към", `transition` позволява единствено той да стигне на целта си и да стане незает.

#### От незаетост единствено можем да започнем затваряне на врати
Докато асансьорът е всъстояние на "незаетост", `transition` позволява единствено той да започне да затваря вратите си.

#### Докато се затварят вратите можем да преминем единствено към незаетост или към пътуване

#### Свойство за производителност/"progress"
От каквото и да е състояние и каквото и да е действие, `transition` винаги ще промени състоянието на асансьора.
